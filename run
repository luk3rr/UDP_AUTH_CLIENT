#!/usr/bin/env python3

"""
Filename: run
Created on: November  5, 2023
Author: Lucas Ara√∫jo <araujolucas@dcc.ufmg.br>

CMake Build and Clean Script

This script provides functions to build and clean CMake projects. It includes
functions for building the project, running the main program, executing unit tests,
and cleaning CMake artifacts.

Usage:
    ./run [OPTIONS]

Options:
    -b, --build        Build the CMake project
    -d, --debug        Build the CMake project in Debug mode
    -e, --exec         Run the main program
    -t, --test         Run the unit tests
    -c, --clean        Clean CMake artifacts
    -v, --valgrind     Run Valgrind tests to check for memory leaks
    -h, --help         Show this help message and exit
    -h, --help         Show this help message and exit
    -x, --exec_args    Arguments for cmake_exec
"""

import os
import subprocess
import argparse
import shutil

BUILD_DIR = "build"
BIN_DIR = "bin"
RELEASE_DIR = "Release"
DEBUG_DIR = "Debug"
PROGRAM_NAME = "program"
UNIT_TEST_NAME = "unit_test"
VALGRIND_MEMLEAK = "valgrind --leak-check=full"
VALGRIND_MASSIF = "valgrind --tool=massif"


def run_valgrind_tests(program_args=None):
    """
    @brief
        Run Valgrind tests on the program and unit tests.

        This function uses Valgrind to check for memory leaks in the program and unit tests.
    """
    cmake_build(debug=True)

    valgrind_memleak_program = [
        f"{VALGRIND_MEMLEAK} {BIN_DIR}/{DEBUG_DIR}/{PROGRAM_NAME}"
    ]

    valgrind_memleak_tests = [
        f"{VALGRIND_MEMLEAK} {BIN_DIR}/{DEBUG_DIR}/{UNIT_TEST_NAME}"
    ]

    valgrind_massif_program = [
        f"{VALGRIND_MASSIF} {BIN_DIR}/{DEBUG_DIR}/{PROGRAM_NAME}"
    ]

    if program_args is not None:
        # Convert program_args to string
        program_args_str = " ".join(map(str, program_args))

        # Append program arguments to Valgrind commands
        valgrind_memleak_program[0] += " " + program_args_str
        valgrind_massif_program[0] += " " + program_args_str

    print("Running Valgrind memleak on program:")
    subprocess.run(valgrind_memleak_program, shell=True, check=True)

    print("Running Valgrind memleka on unit tests:")
    subprocess.run(valgrind_memleak_tests, shell=True, check=True)

    print("Running Valgrind massif on program:")
    subprocess.run(valgrind_massif_program, shell=True, check=True)


def cmake_build(debug=False):
    """
    @brief Build a CMake project in the specified build directory.

    This function creates the build directory if it doesn't exist, changes to that
    directory, runs CMake configuration, and then builds the project.
    """

    check_submodules()

    if not os.path.exists(BUILD_DIR):
        os.makedirs(BUILD_DIR)

    build_type = "Debug" if debug else "Release"
    build_dir = os.path.join(BUILD_DIR, build_type)

    if not os.path.exists(build_dir):
        os.makedirs(build_dir)

    current_dir = os.getcwd()
    os.chdir(build_dir)

    cmake_command = f"cmake ../.. -DCMAKE_BUILD_TYPE={build_type}"
    subprocess.run(cmake_command, shell=True, check=True)

    build_command = "cmake --build ."
    subprocess.run(build_command, shell=True, check=True)

    os.chdir(current_dir)


def cmake_exec(program_args=None):
    """
    @brief
        Build and execute the main program generated by CMake.

        This function triggers the CMake build process and then runs the main program
        located in the binary directory.
    """
    cmake_build()

    exec_command = [f"{BIN_DIR}/{RELEASE_DIR}/{PROGRAM_NAME}"]

    if program_args is not None:
        exec_command += program_args

    subprocess.run(exec_command, check=True)


def cmake_unit_tests():
    """
    @brief
        Build and execute the unit tests generated by CMake.

        This function triggers the CMake build process and then runs the unit tests
        located in the binary directory.
    """
    cmake_build()

    exec_command = f"{BIN_DIR}/{RELEASE_DIR}/{UNIT_TEST_NAME}"
    subprocess.run(exec_command, shell=True, check=True)


def clean_cmake_artifacts(project_path=None):
    """
    @brief
        Cleans the artifacts generated by CMake in a project, including build and binary
        folders.

    @param project_path:
        The path to the project where CMake artifacts should be cleaned. If not
        provided, the current working directory will be used.
    """

    if project_path is None:
        project_path = os.getcwd()

    out_dir = os.path.join(project_path, BUILD_DIR)
    bin_dir = os.path.join(project_path, BIN_DIR)

    if not os.path.exists(out_dir) and not os.path.exists(bin_dir):
        print("No CMake artifacts found to clean")
        return

    # Clean build dir
    if os.path.exists(out_dir):
        for item in os.listdir(out_dir):
            item_path = os.path.join(out_dir, item)

            if item != ".gitkeep":
                if os.path.isdir(item_path):
                    shutil.rmtree(item_path)
                else:
                    os.remove(item_path)

    # Clean bin dir
    if os.path.exists(bin_dir):
        for item in os.listdir(bin_dir):
            item_path = os.path.join(bin_dir, item)

            if item != ".gitkeep":
                if os.path.isdir(item_path):
                    shutil.rmtree(item_path)
                else:
                    os.remove(item_path)

    print(f"Cleaning CMake artifacts for project in: {project_path}")
    print(f"Removing build files: {out_dir}")
    print(f"Removing bin files: {bin_dir}")


def check_submodules():
    """
    @brief
        Check if the project has submodules and update them if necessary.

        This function checks if the project has submodules and updates them if necessary.
    """
    if os.path.exists(".gitmodules"):
        # Check if the submodules are empty
        submodules_dir = "submodules"
        if os.path.isdir(submodules_dir):
            for d in os.listdir(submodules_dir):
                submodule_path = os.path.join(submodules_dir, d)
                if os.path.isdir(submodule_path):
                    if not os.listdir(submodule_path):
                        print(
                            f"The submodule directory {submodule_path} is empty. Updating..."
                        )

                        subprocess.run(
                            [
                                "git",
                                "submodule",
                                "update",
                                "--init",
                                submodule_path,
                            ],
                            check=True,
                        )


def main():
    """
    @brief
        main function
    """
    parser = argparse.ArgumentParser(description="CMake Build, Execute, or Clean")
    parser.add_argument("-b", "--build", action="store_true", help="Run CMake build")
    parser.add_argument(
        "-d", "--debug", action="store_true", help="Build in Debug mode"
    )
    parser.add_argument("-e", "--exec", action="store_true", help="Run CMake execute")
    parser.add_argument(
        "-c", "--clean", action="store_true", help="Clean CMake artifacts"
    )
    parser.add_argument(
        "-t", "--test", action="store_true", help="Run CMake unit tests"
    )
    parser.add_argument(
        "-v",
        "--valgrind",
        action="store_true",
        help="Run Valgrind tests for memory leaks and memory usage",
    )
    parser.add_argument(
        "-x", "--exec_args", nargs=argparse.REMAINDER, help="Arguments for cmake_exec"
    )

    args = parser.parse_args()

    if not any(vars(args).values()):  # No arguments passed by user
        parser.print_help()

    elif args.build:
        cmake_build()

    elif args.debug:
        cmake_build(debug=True)

    elif args.exec:
        cmake_exec(args.exec_args)

    elif args.clean:
        clean_cmake_artifacts()

    elif args.test:
        cmake_unit_tests()

    elif args.valgrind:
        run_valgrind_tests(args.exec_args)


if __name__ == "__main__":
    main()
